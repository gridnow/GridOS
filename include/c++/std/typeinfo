// RTTI support for -*- C++ -*-
/** @file typeinfo
 *  This header provides RTTI support.
 */

#ifndef _TYPEINFO
#define _TYPEINFO

#include <exception>

#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  	class __class_type_info;
} // namespace __cxxabiv1

#ifndef __GXX_MERGED_TYPEINFO_NAMES
  #if !__GXX_WEAK__
    // If weak symbols are not supported, typeinfo names are not merged.
    #define __GXX_MERGED_TYPEINFO_NAMES 0
  #else
    // On platforms that support weak symbols, typeinfo names are merged.
    #define __GXX_MERGED_TYPEINFO_NAMES 1
  #endif
#endif

namespace std 
{
  	/**
   	*  @brief  Part of RTTI.
   	*
   	*  The @c type_info class describes type information generated by
   	*  an implementation.
  	*/
  	class type_info 
  	{
  		public:
    	/** Destructor. Being the first non-inline virtual function, this
     	*  controls in which translation unit the vtable is emitted. The
     	*  compiler makes use of that information to know where to emit
     	*  the runtime-mandated type_info structures in the new-abi.  */
    		virtual ~type_info();

  		private:
    		/// Assigning type_info is not supported.  Made private.
    		type_info& operator=(const type_info&);
    		type_info(const type_info&);
    
  		protected:
    		const char *__name;
    
  		protected:
    		explicit type_info(const char *__n): __name(__n) { }
    
  		public:
    		// the public interface
    		/** Returns an @e implementation-defined byte string; this is not
     			*  portable between compilers!  */
    		const char* name() const
    		{ return __name; }

#if !__GXX_MERGED_TYPEINFO_NAMES
    	bool before(const type_info& __arg) const;
    	// In old abi, or when weak symbols are not supported, there can
    	// be multiple instances of a type_info object for one
    	// type. Uniqueness must use the _name value, not object address.
    	bool operator==(const type_info& __arg) const;
#else
    	/** Returns true if @c *this precedes @c __arg in the implementation's
     	*  collation order.  */
    	// In new abi we can rely on type_info's NTBS being unique,
    	// and therefore address comparisons are sufficient.
    	bool before(const type_info& __arg) const
    	{ return __name < __arg.__name; }
    	bool operator==(const type_info& __arg) const
    	{ return __name == __arg.__name; }
#endif
    	bool operator!=(const type_info& __arg) const
    	{ return !operator==(__arg); }
    
    	// the internal interface
  	public:
    	// return true if this is a pointer type of some kind
    	virtual bool __is_pointer_p() const;
    	// return true if this is a function type
    	virtual bool __is_function_p() const;

    	// Try and catch a thrown type. Store an adjusted pointer to the
    	// caught type in THR_OBJ. If THR_TYPE is not a pointer type, then
    	// THR_OBJ points to the thrown object. If THR_TYPE is a pointer
    	// type, then THR_OBJ is the pointer itself. OUTER indicates the
    	// number of outer pointers, and whether they were const
    	// qualified.
    	virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
			    unsigned __outer) const;

    	// internally used during catch matching
    	virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
			     void **__obj_ptr) const;
	};

  	/**
   	*  @brief  Thrown during incorrect typecasting.
   	*
   	*  If you attempt an invalid @c dynamic_cast expression, an instance of
   	*  this class (or something derived from this class) is thrown.  */
  	class bad_cast : public exception 
  	{
  		public:
    		bad_cast() throw() { }
    		// This declaration is not useless:
    		// http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    		virtual ~bad_cast() throw();
  	};
  
  	/** If you use a NULL pointer in a @c typeid expression, this is thrown.  */
  	class bad_typeid : public exception 
  	{
  		public:
    		bad_typeid () throw() { }
    		// This declaration is not useless:
    		// http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    		virtual ~bad_typeid() throw();
  	};
} // namespace std

#pragma GCC visibility pop

} // extern "C++"
#endif
